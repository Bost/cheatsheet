<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN""
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <head>
        <link href="google-code-prettify/prettify.css" type="text/css" rel="stylesheet" />
        <script type="text/javascript" src="google-code-prettify/prettify.js"></script>
        <!--<link rel="icon" type="image/png" href="favicon.png" />-->
        <meta http-equiv="content-type" content="text/html; charset=utf-8" />

        <title>Patterns</title>
</head>
<body onload="prettyPrint()" style="font-size: 11px">
    TODO try out literate programming
    Abstract classes == terms (pojmy)
    DIP - Dependency Inversion Principle: Classes should depend on abstract classes, not implementation details
    <div class="pattern">
    <pre class="prettyprint lang-java">
    // Demeter's law: Do not use:
    String outDir = context.getOptions().getScratchDir().getAbsolutePath();
    String outFile = outDir + "/" + className.replace('.', '/') + ".class";
    FileOutputStream fout = new FileOutputStream(outFile);
    BufferedOutputStream bos = new BufferedOutputStream(fout);

    // replace it with
    BufferedOutputStream bos = context.createScratchFileStream(fout);</pre>
    <div class="explanation">
        Advantages: Objects should not know about internal structure of other objects
                    Layering
                    Narrow interfaces at the method level

        Disadvantages: Wide (enlarged) interfaces at the class level (see aspect orientation)
    </div>
    </div>
    <pre class="prettyprint lang-java">
    void monad(String a0);
    void dyad(String a0, String a1);
    void triad(String a0, String a1, String a2);</pre>

    <div class="explanation">
        Expression Problem (TODO check name)
        Objects:
        add new property - easy
        add new method - hard. This new method must be added to every derrived object.

        Data Structures (DTOs):
        add new method - easy
        add new property - hard. This new property must be 'processed' by every method working with given DTO.
    </div>

    1. create try-catch tests:
    <pre class="prettyprint lang-java">
    // step1
    @Test(expected = StorageException.clsas)
    public void retrieveSection_throwExceptionOnInvalidFileName() {
        sectionStore.retrieveSection("invalid-file");
    }

    public List<RecordedGrip> retrieveSection(String sectionName) {
        // return empty value until real implementation is done
        return new ArrayList<RecordedGrip>();
    }

    // step2 - the real implementation
    public List<RecordedGrip> retrieveSection(String sectionName) {
        try {
            FileInputStream stream = new FileInputStream(sectionName);
        }
        catch (Exception e) {
            throw new StorageException("retrieval error", e);
        }
        return new ArrayList<RecordedGrip>();
    }

    // step3 - narrow down to FileNotFoundException
    public List<RecordedGrip> retrieveSection(String sectionName) {
        try {
            FileInputStream stream = new FileInputStream(sectionName);
            // the business logic may come here safely - we know here the stream
            // has been successfuly created
            stream.close();
        }
        catch (FileNotFoundException e) {
            throw new StorageException("retrieval error", e);
        }
        return new ArrayList<RecordedGrip>();
    } </pre>

    <div>
        Interface Border exploration - use it to test new releases of a new 3th party package realese:
    <script type="text/java" src="LogTest.java"></script>
        <pre class="prettyprint lang-java">
    // TODO include LogTest.java as an external file
    public class LogTest {
        private Logger logger;

        @Before
        public void initialize() {
            logger = Logger.geetLogger("logger");
            logger.removeAllAppenders();
            logger.getRootLogger().removeAllAppenders();
        }

        @Test
        public void basicLogger() {
            BasicConfigurator.configure();
            logger.info("basicLogger");
        }

        @Test
        public void addAppenderWithStream() {
            logger.addAppender(new ConsoleAppender(
                new PatternLayout("%p %t %m%n"),
                ConsoleAppender.SYSTEM_OUT));
            logger.info("addAppenderWithStream");
        }

        @Test
        public void addAppenderWithoutStream() {
            logger.addAppender(new ConsoleAppender(
                new PatternLayout("%p %t %m%n")));
            logger.info("addAppenderWithoutStream");
        }
    }</pre>
    </div>

    <div>
        Dependency Injection - a variant of IoC (Inversion of Control)
        <pre class="prettyprint lang-java">
    // partial implementation of DI:
    MyService myService = (MyService) jndiContext.lookup("MyServiceName");</pre>
    </div>

    <div>
        <pre class="prettyprint lang-java">
    // original code:
    Complex c = new Complex(-1, 0);

    public class Complex {
        public static Complex fromCartesianFactory(double real, double imaginary) {
            return new Complex(real, imaginary);
        }
        public static Complex fromPolarFactory(double modulus, double angle) {
            return new Complex(modulus * cos(angle), modulus * sin(angle));
        }
        /** we want to make the default constructor invisibe - thus private or protected
         * Disadvantages:
         * - every(!) original 'new Complex(x, y)' must be replaced by fromCartesianFactory or fromPolarFactory
         * - the subclass must provide its own re-implementation of all factory methods with exactly the same
         *   signatures. For example, if class StrangeComplex extends Complex, then unless StrangeComplex
         *   provides its own version of all factory methods, the call.
         */
        private Complex(double a, double b) {
            //...
        }
    }

    Complex c = Complex.fromCartesianFactory(-1, 0);</pre>
    </div>
</body>
</html>
