A Crash Course in Category Theory - Bartosz Milewski https://www.youtube.com/watch?v=JH_Ou17_zyU
https://twitter.com/@bartoszmilewski
Computer Science, Haskell, C++. PhD in Quantum Physics

* Ultimatelly the human lang to talk about ideas is the lang of math.
  Formullas, Multiplication, stupid mistakes in deriving, simplification etc.
  CT Looks nicer: no numbers, it's about ideas

Programming - understanding the meaning i.e. semantics: what does it mean (+ 1 2)
* Operational: "if state === stateX then state = stateY":
  for computers: local, progress oriented
  Mind machine: We keep on imagining the if-then-else steps.
  This is bad way - computers are much better at it.
* Denotational:
  programs can be translated to math - math is a better lang for humans
  "Programm has a meaning i.e. it's a piece of math: operation, declaration, definition"
* Math: for humans by humans


Functional Programming - mathematical semantics:
* Types and fns:
** types: sets of vals; it's not about "how" - fn body, it's about "what" - fn declaration; abstraction
   For mathematicians Set Theory is a low level assembly lang of maths - recenty started to be avoided:
*** HoTT
*** CT (Sets form a Category)
** (pure) fns: mappings between sets


* categorical view (simplification):
** fns: arrows between objs
** types: objs whose props are defined by arrows
*** composition(!) "this-fn after that-fn", associativity, identity

- no deeper specification of fns and objs are

Mapping between CT and FP:
* Views -> Change of perspective:
** Set-theoretical: props of sets defined by elems of sets
** Categorical: Shrink the set to a point "I can't look at the structure of a set"
- describe different kinds of sets by their interraction with other sets - i.e. by arrows
- tell me who your friends are and I tell you who you are



Phenomenons of Introduction and Elimination

Data types:
* Void (empty set): we don't know that it has no elems; describe/define the props
  using arrows, i.e. saying something universal; universal property UP
  initial obj: Univ prop: unique(1.) arrow to every(2.) single other obj
  (corresponds to falsehood in logic)
** intro: can't be constructed (can't construct a fn returning an elem of empty set)
   ??? Identity fn on void ???
** elim: Void -> A (arrow from; polymorphic fn - works for any type)

* Unit (one-elem set): univ prop: terminal obj (opposite i.e. dual to init-obj); Duality - invert the arrows and you get something for free
** intro: A -> Unit (fn: just ignore the fn input)
** elim: Unit -> A (fn: pick one elem of a type i.e. set; some sort of "cheating" - instead of an elem we pick a morphism)

* Cartesian product (set of pairs): UP (universal construction) - best product triangle: for all other types there's the unique arrow
  projections: f: C -> A, g: C -> B
- tuple (pair aka record) is better than tripple
??? loop-over-all-types: for each of all possible types: 38:20
** intro: A -> B -> (A,B) tupple
** elim: (A,B) -> A, (A,B) -> B

* Sum type (dual to product - coproduct)
** intro: A -> either A or B, B -> either A or B
** elim: case e of: left a -> f a, right b -> f b
** in FP tagged unions

* Monoidal Cat: (objs, arrows, prods) looks kinda like multiplication / addition

Algebra of types ...

* Functor: mapping between Cats (objs to objs, fns to fns), preserves structure:
  i.e. if threre's an arrow A -> B, then there must be arrow F(A) -> F(B); may collapse things, preserves unit obj and composition.
** Endofunctors - mapping from the same Cat to the same Cat. Endo ~ inside, "Endoscopy"

* Adjunction: A pair of ftors: one ftor F adjunct to another ftor G; F and U are not an inverse of each other
  Obj in a Cat of Types such that: For every A, B there is a set of arrows from A to B.
  This obj is called function-type. It can be defined by an adjuction of two endo-ftors
** It's more interesting if F, G are not an inverse of each other
** F left adjoing to G:
*** left side: prepare an argument for some function using functor F
*** right side: modifying the output of some function using functor G
 F A === (A, C)   ftor F acts on A and creates a pair type (A, C)
 G B === C -> B   ftor G acts on B and creates a function type from C to B

Currying arrises from an Adjunction:
  (A, C) -> B is isomorphic (i.e. equivalent) to A -> (C -> B)

If you have a pairing (product) and if you have such an adjunction in your Cat then you are able to define a function type (en exponential).
A Cat with such pairing and adjunction is called cartesian closed (i.e. this Cat has a function type)

** function intro: lambda
** function elim: eval

* Natural transformations: Polymorphic functions: mapping between ftors:
see picture at https://youtu.be/JH_Ou17_zyU?t=1h6m23s
Polymorphic function - a function for every single type i.e. multiplication (Product) of all obj in a category.
(also the dual - the Sum)
Categorical End and CoEnd - notation is the integral sign

Monadic return-function is an universally polymorphic function - works for any type
https://www.youtube.com/watch?v=CfoaY2Ybf8M&t=7m

Yoneda Lema - a description how you can perform these integral if you have a Hom Functor

* Ftor Category:
** pick two Cats C, D; ftors from C to D form a Ftor Cat [C, D]: Objs are ftors, arrows are Nat Transf
Endofunctors: functors from C to C: [C, C]


* Yoneda Embedding https://youtu.be/JH_Ou17_zyU?t=1h8m9s
** Ideaa: Replace a content of an obj A (picked i.e. fixed) by a totality of arrows ending in this obj. It's content and props.
** Set of arrow from every possible X to A

*** Mapping from X to the set of arrows X->A, for every obj A I get a differecnt ftor from C to Set
*** vary the A obj:

Khan Extentions
* Generalisation of everything. They sub-sume everything else, like adjuctions at a higher level
* Limits Colimits Monads Adjunctions can be redefined as Khan Extentions
* Intuition of Khan Extention is ...
