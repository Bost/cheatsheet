* Lambda Calculus: formal calculus for manipulating functions
  Currying: Partial function application; Fixing some function parameters
* Category Theory: abstract algebra of abstract functions: "The Arrows Count"
** Cartesian Closed Category CCC: Usefull in programming
*** cartesian: has product A x B (conjunction) for any pair of objs A, B
*** closed: has exponential B^A (functions) for any pair of objs A, B
*** 0-th power of an obj: has terminal obj 1 (for all objs there exists an unique map A → 1)
   - multiplying by terminal obj 1 gives back the original obj
   - dual to terminal obj 1 is the initial obj; Top and Bottom objs
   i.e. any one-element set (= singleton) is terminal
   DTTO for poset 1 is such an object that any other obj is below it

   - ? monoindal structure on objs ?
*** Localy CCC: for every obj X sliced category is a CCC
** Bi Cartesian Closed Category BCCC: Algebra of Types can be made here
*** has coproduct for every pair of objs
*** has initial obj

** Universal Mapping Property (UMP): Consists of Initial and Terminal mapping (morphism). The 'double' triangle of Product
   Universal Construction - 3 steps (? the triangle ?):
   1. Define a pattern:

         Z'  (Z' x A) ---\
         ⎢       ⎢        \
       h ⎢       ⎢id       \ g'
         ⎢       ⎢          \
    a=>b ↓       ↓           ↘
         Z   (Z x A) -------> B
                 A      g

    g' = g ∘ (h x id)

   2. Define ranking between matches
   3. The best match is "our guy"

** Bartosz Milewsky:
   Most important features of a category: ?, Composability, Identity
   Example in programming: Category of Types and Functions (set and functions between sets)
*** Designing computer language:
    Semantics must be provided; done by providing operational semantics
    None of  the main prog. languages have (operational semantics) only partially provided;
    Two ways of defining semantics:
    - Operational: "How it executes"
    - Denotational: mapping into mathematics

*** Cartesian Product CP: set of all pairs
    Relation: A subset of CP; doesn't have a directionality; n-to-n relation
*** Functions: (Sets and functions between sets)
    Pure: must be memoizable (lookup table)
    Total: defined for all arguments
    Partial: defined only for some arguments
    Directionality (arrow from->to i.e. functions are not symetric); n-to-1 relation
    - Inverse of function is not guaranteed to exist

    Domain, Codomain, Image
*** Morphisms:
    | Latin      | Greek                | Meaning                    | Functor  |
    |------------+----------------------+----------------------------+----------|
    | injective  | monic / monomorphism | distinct Xs -> distinct Ys | Faithful |
    | surjective | epic / epimorphism   | all Ys are used            | Full     |

*** Functor:
    - preserves structure between 2 categories, i.e. is a homomorphism by definition
    - in programming: total mapping of types; (total = all objs from the source are mapped)
    - Constant functor: collapses all objs into 1 obj and all morphisms into an identity
    - Intuitive understanding: (endo) functor is a container - i.e. list contains values
    - function itself can be regarded as a container. E.g. identity function;
      functions (when evaluated) return value i.e. data are represented as values
      functions and data are the same
      function type is an exponential which is a data type; (Exponential is like an interated product)
    - Endofunctor: A functor that maps a category to itself.

*** Bifunctor: C × D → E
    Product is a bifunctor, i.e. it takes 2 objs and produces 3rd obj,
    but it also takes two morphisms and produces 3rd morphism which is a product of these two
    morphisms
**** List: List(α) = Nil | Const α (List α)
    - most intuitive example of a functor
    - type constructor: takes a type α and creates a list of α

    Sum (+) and Product (*) are algebraic data types (Algebra on Types):
    List(α) = Nil | Const α (List α) ~ L(α) = 1 + α * L(α) => .. => L(α) = 1 / (1 - α) =
    = 1 + α + α*α + α*α*α + ...

    Is product a functor?

    Inlining and refactoring are the opposite.** Fibre: a buch of points mapped to the same value; invertibility of a function to a fibre

    Lifting (= applying functor):
                F f
          F a ------> F b
           ↑           ↑
           |     f     |
           a --------> b

** Natural Transformation: a way of/for comparing functors
   - maps morphism(s) to commuting diagram(s) (naturality squares).
     i.e. comorphism: replacing a square of (complex) relations with a single morphism
   - picks a morphish between two objs; Picking 1 morphishm from a homset
   - Components of NaT
   - Composing functor acting on an obj with a functor acting on a morphishm
     Alpha b * F f

   - polymorphic function

   - Functor is a container, NaT repackages the container

** Fibre: a buch of points mapped to the same value; invertibility of a function to a fibre
** Abstraction: i.e. non-invertibility
   - from all properties (i.e. all points of a fibre) I'm interested only in one
   - e.g. I'm not interested in what was the exact input value of a function,
     I'm interested only if it was an even or odd value
** Modeling: mapping / injecting
   * Category ℂ = (Obj, hom, ◦, id)
   Obj - Class of Objects: A, B, C, ... (Objs are in fact Types / Propositions)
   hom - Morphisms (arrows): f, g, h, ... (morphisms are Computation / Proofs)
   ◦ - function c for composing morphisms: associative
   ◦ - morphism composition: hom(A, B) × hom(B, C) → hom(A, C): g ◦ f; it's a partialy binary operation on Mor(CAT::)
   A collection of arrows and morphism that can be composed if they are adjacent.
   A structure packing structures of the same type (same category) and structure preserving mappings between them.
   id - identity morphism on object A: id(A)
   Small Category: all objs and morphisms are sets
   Localy Small Category: ∀ A,B: Hom(A, B) is a set
   Sheaf (Garbe, Faisceau, zvazok)- tool for tracking locally defined data
   Presheaf: Functor F: ℂop → Set
** Homset: Homℂ(A,B) = {f: A → B} - set of all morphisms A → B in category ℂ (Objs of ℂ don't need to be sets)
   External vs. Internal Homset

** Representable Functor F: ℂ → Set
   "Representing objs and morphisms of ℂ as sets and functions in Set"
   i.e. functions "tabulate", "index" can be created; mapping of function to a data-type

   fix obj A ∈ ℂ there is Homℂ(A,_): Homℂ(A, X) → Homℂ(A, Y) where there is a morphism X → Y
   e.g.:
   The forgetful functor Grp → Set on the category of groups (G, *, e) is represented by (Z, 1).
   The forgetful functor Ring → Set on the category of rings is represented by (Z[x], x), the polynomial ring in one variable with integer coefficients.
   The forgetful functor Vect → Set on the category of real vector spaces is represented by (R, 1).
   The forgetful functor Top → Set on the category of topological spaces is represented by any singleton topological space with its unique e
** Naturality condition: Gf ∘ αa = αb ∘ Ff
*** Homomorphism: structure-preserving mapping between 2 algebraic structures (e.g. monoids, groups, rings, vector spaces).
    f(m * n) = f(m) * f(n)

    Individual monoids themselves give category
    Monoids with homomorphisms give category

** Kleisli category: Monad a -> (b, Bool)

* Curry-Howard-Lambek correspondence: Logic <-> Type Theory <-> Category Theory:
  Function A -> B is a proof of logical implication A => B
  Direct relationship between computer programs and mathematical proofs; from 1940-ties
  Link between Computation and Logic;
  Proofs-as-programs and propositions- or formulae-as-types interpretation;
  Proofs (= Programs) can be executed;
  Typed lambda calculi derived from the Curry–Howard-Lambek paradigm led to software like Coq;
  Curry-Howard-Lambek correspondence might lead to unification between mathematical logic and foundational computer science;
  Popular approach: use monads to segregate provably terminating from potentially non-terminating code

    | LOGIC (Howard)                                 | TYPE THEORY (Curry)                                                  | CATEGORY THEORY (Lambek) |
    |------------------------------------------------+----------------------------------------------------------------------+--------------------------|
    | Proposition of some type - (something is true) | Type (contract - a set of values that passes the contract)           |                          |
    | Proof of some type                             | Term (A program - guarded fn)                                        |                          |
    | Normalisation (Proof equality)                 | Computation (substitute variable with value)                         |                          |
    |------------------------------------------------+----------------------------------------------------------------------+--------------------------|
    | P implies Q: P -> Q (i.e. there exists one)    | paricular fn of fn of P-contract to guarded fn of Q-contract: P -> Q |                          |
    | -> is constructive implication                 | -> is function from-to                                               |                          |
    | false      -> false (implies)                  | {}       ->  {}  no values (empty set); contract cannot be satisfied |                          |
    | false      -> true                             | {}       ->  {.} (one element set)                                   |                          |
    | true       -> true                             | {.}      ->  {.} (identity function)                                 |                          |
    | true  (not ->) false (does not imply)          | {.} (not ->) {}                                                      |                          |


** Correspondance of type habitation and proposition
   inhabited - has elems / members
   "Either a b" is inhabited if either a or b is inhabited (at least one of them is true / provable)

   Curry: ((a,b) -> c) -> (a -> (b -> c))
   Uncurry: (a -> (b -> c)) -> ((a,b) -> c)

   Eval: a function of two args / a pair
   "((a => b), a) -> b" this is modus-ponens in logic "a => b ∧ a -> b"

    | True proposition | False proposition | Conjunction a ∧ b         | Disjunction a ∨ b           | Implication a => b   |
    | Unit-type        | Void-type         | Pair (a,b)                | Either a b                  | Function type a -> b |
    | sinhabited       | not inhabited     |                           |                             |                      |
    | Terminal obj     | Initial obj       | Categorical product a × b | Categorical coproduct a ⎥ b | Exponential obj b^a  |


    0 - void type - ?
    1 - unit type - 0th-power: terminal obj
    2 - bool type (two possible values): 1st-power: the obj itself
    3 - int type - 2nd-power: product
    4 - real type (if continuum hypothesis holds :-)
    5 - ? type

*** JavaScript & Category Theory
**** Category ==  Contracts + Functions guarded by contracts

**
| Set theory                  | Category theory                                          | JavaScript                     |
|-----------------------------+----------------------------------------------------------+--------------------------------|
| membership relation         | -                                                        |                                |
| elements                    | objects                                                  | contracts                      |
| sets                        | categories                                               |                                |
| -                           | morphisms (structure-preserving mapping between objects) | functions guarded by contracts |
| functions                   | functors  (maps between categories)                      |                                |
| equations between elements  | isomorphisms between objects                             |                                |
| equations between sets      | equivalences between categories                          |                                |
| equations between functions | natural transformations (maps between functors)          |                                |

Categorification: process of weakening structure, weakening equalities down to natural isomorphisms and then adding-in rules
that these natural isomorphisms have to follow (so it behaves well)
Counting number of elements in sets is decategorification; from category we get set or from set we get a number

Monoid homomorphisms: a function between the sets of monoid elements that preserved the monoid structure
Monoidal functors:    a functor between categories that preserves the monoidal structure (should preserve multiplication)
              from functor(prodn([x, y, ..])) to prodn([functor(x), functor(y), ..])
Monoidal monad:       ???

Functor:
"forget the indexing (domain functor)"

*** Contract = Object
*** Product: examples:
    Objects   - numbers
    Morphisms - functions 'less/greater or equal than'

* Isomorphism (bijection when f is a function on set / sets):
  ∀ f: X → Y  there ∃ g: Y → X such that g ∘ f = idX and f ∘ g = idY; idX, idY are identity morphisms on X, Y
  (f is invertible and g is the inverse of f)

** Category theory - Modeling (new vocabulary)
   | hierarchies                | partial orders     |
   | symmetries                 | group elements ?   |
   | data models                | categories         |
   | agent actions              | monoid actions     |
   | local-to-global principles | sheaves (lanovica) |
   | self-similarity            | operads            |
   | context                    | monads             |


** olog = ontology log
   Different branches of mathematics can be formalized
   into categories. These categories can then be connected together by functors. And the
   sense in which these functors provide powerful communication of ideas is that facts and
   theorems proven in one category can be transferred through a connecting functor to
   yield proofs of an analogous theorem in another category. A functor is like a conductor
   of mathematical truth.

* Mappings: X → Y (Zobrazenia):
** Surjection: all Ys are used;                                     |X| ≥ |Y| (onto; "at least as big")
** Injective:  distinct Xs -> distinct Ys;                          |X| ≤ |Y| (? one-to-one ?)
** Bijection:  exact pairing between X, Y;                          |X| = |Y| (vzajomne jednoznacne zobrazenie, "same size")
** Strict:     Surjection from X to Y but no bijection from Y to X; |X| < |Y| (? double usage of some Ys ?, "strictly bigger")

* Math Structures:
** Monoid (M, *, e); Also a Category 'many' morphisms and 'few' (only one) object M
  (like Group withouth inverse elements)
  M - non-empty set
  * - associative operation: (x * y) * z = x * (y * z)
  e - neutral element of M (identity)

** Group (G, *, e): One set G of elements with a 'multiplication' operation (formalization of symetry concept)
  like Monoid; plus every element has its inverse: x-inverse (dual obj): x * x-inverse = x-inverse * x = e
  (i.e. a Category with one object; every morphism is an isomorphism)
  closure: a and b and a*b must be membembers of the same group
  commutativity is not a part of the group definition: x * y = y * x
** Cyclic Group: generated by one element.
** Semigroup: A set with an associative binary operation: x * y
   generalizes a group by preserving only associativity and closure under the binary operation from the axioms defining a group
** Ring (M, +, *) - Okruh
** PreOrder (A, ≤)
   A - nonempty set
   ≤ - pre-ordering relation: must be
                   - reflexive: a ≤ a
                   - transitive: a ≤ b and b ≤ c then a ≤ c

** PoSet - Partialy Ordered Set (A, ≤); Also a Category with 'few' (only one) morphisms between any two objects and many objects
   A - no-nempty set
   ≤ - relation: must be
                   - reflexive: a ≤ a
                   - transitive: a ≤ b and b ≤ c then a ≤ c
                   - aymetric: a ≤ b and b ≤ a then a = b
** TODO Pointed Set
** TODO Pointed Function
** TODO Top (Topological Space)
** eval, exponent in Category Theory
** Propositional Logic

* Beta β reduction (computational) / Eta η extentionality principle
  β reduction in computation: Simplify proofs by replacing formal params with terms.

  fst<Alpha, Beta> = Alpha
  snd<Alpha, Beta> = Beta
  (lambda x.Beta)Alpha = [Alpha/x]Beta
  (lambda x.f)x = f

* Type Theory: Extention of lambda calculus with explicit types
** ITT Inentional Type Theory
** OTT Observational Type Theory
   Type of a Variable - a set(?) of possible values of that type
   From context Gamma a M can be derrived such that x:A.B
   Context Gamma, x:A, y:Bx (e.g. x be a number with property Bx, y is a variable for the proof of type Bx)
   What's the point of having a number? Well we can count up to that number.
   Depandent type theory is the master theory of all programming languages. If you understand dependent type theory then you understand everything (every programming language)

   Maybe Type: A or B (e.g. A or Fail, A or AirMessage)

* Axiom of Choice - see "Type Theory Foundations, Lecture 3-wJLTE8rnqH0.mp4"
"the greatest intelectual achievement???"

predicate = vyrok = tvrdenie

(Banach Tarsky Paradox: Slice up an object with a volume into parts with no volume, and by putting it together get 2 same objects - "create an object for free")

* Haskell / Agda comparison:

|             | Haskell                              | Agda                                     |
|-------------+--------------------------------------+------------------------------------------|
|             |                                      | full higher order logic with existential |
|             |                                      | and universal quantification             |
|-------------+--------------------------------------+------------------------------------------|
| Type system | Unsound                              | sound                                    |
|             | (arbitrary properties can be prooven |                                          |
|             | i.e. every single type is inhabited) |                                          |
|             | (loop : A, loop = loop)              |                                          |
|-------------+--------------------------------------+------------------------------------------|
|             |                                      | ? Always terminates ?                    |

* Modus Pones: applications of a function to an argument: Agda, Coq, Isabelle
** MP naturally generalizes to instationation of universal quantifiers
* Goedel's Incompleteness Theorem:
 Every principle is either (A) too restrictive or (leaves out a good programm) or (B) not restrictive enough (allows some bad programs).
* Full employment Theorem: take (A) and search for a new class to add in order to improve the language withouth allowing bad programs.
* Clojure:
** Namespace is a Type
   Namespace contains fns returning values of the same Type. I.e. it is a set of Proofs of a given Proposition (i.e. of a given Type).
** Use morphism from "complicated" Types (i.e. Products consisting of many Types. E.g. maps each having many keys) to subsets of (if possible natural) numbers.
   These subsets should be in fact monads

   inl(...) - injection to the left
   inr(...) - injection to the right

   (A * B) and (A + B) could be seen as a product (e.g. join) and coproduct (e.g. disjoint union) of A and B

* Theory of Reflexive Domain 1:21 Video 2
* Logic examples:
  | Logical Judgement   | Branch of Logic   | Computation phenomenon                     |
  |---------------------+-------------------+--------------------------------------------|
  | K knows A           | Epistemic Logic   | Distributed Computing                      |
  | A is true at time t | Temporal Logic    | Reactive Programming (partial evaluation)  |
  | A is a resource     | Linear Logic      | Concurrent Computation                     |
  | A is possible       | Monadic Lax Logic | Generic effects (monads, state, exception) |
  | A is valid          | Modal Logic       | Runtime code generation                    |

** Linear Logic: limited resources: construction / descruction
   ? Unique pointers in C++ ?, "Stuff moved from place to place and it cannot be used twice only once"
** Intuitionistic (Constructive) Logic: endless resources, no need for construction / descruction
** Higher order logic

* Impossibility of a perfect type-checker for a programming language
  It it’s impossible to have a procedure that figures out whether an arbitrary
  program halts, it’s easy to show that it’s impossible to have a procedure that
  is a perfect recognizer for any overall run time property.

  A program that type-checks is guaranteed not to cause a run-time type-error.
  But since it’s impossible to recognize perfectly when programs won’t cause
  type-errors, it follows that the type-checker must be rejecting programs that
  really wouldn’t cause a type-error. The conclusion is that no type-checker is
  perfect—you can always do better!
* Krakatoa and Jessie: verification tools for Java and C programs
  Why3: platform for deductive program verification
  git clone https://scm.gforge.inria.fr/anonscm/git/why3/why3.git
  A user can write WhyML programs directly and get correct-by-construction OCaml programs through an automated extraction mechanism

* Proof Theory: Proof of soundness, proof of completeness
  experiment, observation
  sampling, counter examples
  judge, jury, religion, boss, conviction "No bugs in my code!"
  "I don't see why not": psycho (the oposing party must find argument)

  A mathematical proof is a verification of a proposition by a chain of logical deductions from a set of axioms

  Proposition is a statement: can be true or false
  Predicate is a proposition: truth depends on the values of variable(s)
