* Lambda Calculus: formal calculus for manipulating functions
  Currying: Partial function application; Fixing some function parameters
  e ::= x | λx.e | e e'
        |    |      |
        |    |      +---- application
        |    +----------- function abstractions
        +---------------- variable

* Typed Lambda Calculus
  e ::= x | λx.e : τ | e e' | c

* Damas-Hindley-Milner Calculus 
  e ::= x | λx.e | e e' | let x = e in e'
  W Algorithm - for type inference: W(Γ,e) = (S,τ)
  Γ - typing env
  S - state
  τ - type

* Category Theory: abstract algebra of abstract functions: "The Arrows Count"
  (TODO arrow weight = price of calculation; preference for compositions)
  Up to isomorphis = any such things are isomorphic (structurally the same)
  i.e. working via analogy (i.e. X is just a renamed version of Y)
** Cartesian Closed Category CCC: Usefull in programming
*** cartesian: has product A x B (conjunction) for any pair of objs A, B
*** closed: has exponential B^A (functions) for any pair of objs A, B
*** 0-th power of an obj: has terminal obj 1 (for all objs there exists an unique map A → 1)
   - multiplying by terminal obj 1 gives back the original obj
   - dual to terminal obj 1 is the initial obj; Top and Bottom objs
   i.e. any one-element set (= singleton) is terminal
   DTTO for poset 1 is such an object that any other obj is below it

   - ? monoindal structure on objs ?
*** Localy CCC: for every obj X sliced category is a CCC
** Bi Cartesian Closed Category BCCC: Algebra of Types can be made here
*** has coproduct for every pair of objs
*** has initial obj

** Universal Mapping Property (UMP): Consists of Initial and Terminal mapping (morphism). The 'double' triangle of Product
   Universal Construction - 3 steps (? the triangle ?):
   1. Define a pattern:

         Z'  (Z' x A) ---\
         ⎢       ⎢        \
       h ⎢       ⎢id       \ g'
         ⎢       ⎢          \
    a=>b ↓       ↓           ↘
         Z   (Z x A) -------> B
                 A      g

    g' = g ∘ (h x id)

   2. Define ranking between matches
   3. The best match is "our guy"

** Bartosz Milewsky:
   Most important features of a category: ?, Composability, Identity
   Example in programming: Category of Types and Functions (set and functions between sets)
*** Designing computer language:
    Semantics must be provided; done by providing operational semantics
    None of  the main prog. languages have (operational semantics) only partially provided;
    Two ways of defining semantics:
    - Operational: "How it executes"; reduction relation: e1 -> e2
    - Denotational: mapping into mathematics; interpretation of terms: ⟦e⟧ = ?;
      e.g.: ⟦ v : τ  ⊢  v : τ ⟧ = idτ - i.e. the meaning of is ⟦...⟧ is an identity on τ i.e. an access to variable v

*** Cartesian Product CP: set of all pairs
    Relation: A subset of CP; doesn't have a directionality; n-to-n relation
*** Functions: (Sets and functions between sets)
    Pure: must be memoizable (lookup table)
    Total: defined for all arguments
    Partial: defined only for some arguments
    Directionality (arrow from->to i.e. functions are not symetric); n-to-1 relation
    - Inverse of function is not guaranteed to exist

    Domain, Codomain, Image
*** Morphisms:
    | Latin      | Greek                | Meaning                    | Functor  |
    |------------+----------------------+----------------------------+----------|
    | injective  | monic / monomorphism | distinct Xs -> distinct Ys | Faithful |
    | surjective | epic / epimorphism   | all Ys are used            | Full     |

*** Functor:
    - preserves structure between 2 categories, i.e. is a homomorphism by definition
    - in programming: total mapping of types; (total = all objs from the source are mapped)
    - Constant functor: collapses all objs into 1 obj and all morphisms into an identity
    - Intuitive understanding: (endo) functor is a container - i.e. list contains values
      (Comonad is a container that already comes prefilled with many values and
      with an access point to one particular value. E.g. hidden params (for
      hidden param propagation it's better to use comonad than monad), history,
      neighbourhood etc.)
    - function itself can be regarded as a container. E.g. identity function;
      functions (when evaluated) return value i.e. data are represented as values
      functions and data are the same
      function type is an exponential which is a data type; (Exponential is like an interated product)
    - Endofunctor: A functor that maps a category to itself.

  | Covariant Functor                       | Contravariant Functor                      |
  | G f :: (a -> b) -> (G a -> G b)         | G f :: (a -> b) -> (G b -> G a)            |
  | Same directions in src and dst Category | Reverse directions in src and dst Category |

*** Bifunctor: C × D → E
    Product is a bifunctor, i.e. it takes 2 objs and produces 3rd obj,
    but it also takes two morphisms and produces 3rd morphism which is a product of these two
    morphisms
**** List: List(α) = Nil | Const α (List α)
    - most intuitive example of a functor
    - type constructor: takes a type α and creates a list of α

    Sum (+) and Product (*) are algebraic data types (Algebra on Types):
    List(α) = Nil | Const α (List α) ~ L(α) = 1 + α * L(α) => .. => L(α) = 1 / (1 - α) =
    = 1 + α + α*α + α*α*α + ...

    Is product a functor?

    Inlining and refactoring are the opposite.** Fibre: a buch of points mapped to the same value; invertibility of a function to a fibre

    Lifting (= applying functor):
                F f
          F a ------> F b
           ↑           ↑
           |     f     |
           a --------> b

*** Yoneda Lemma: [ℂ,Set](ℂ(a,-), F) ⋍ F a
    a - some arbitrary obj of ℂ
    F - some arbitrary functor acting on a
    ⋍ - "naturally isomorphic" (i.e. a NaT exists whose components are all invertible isomorphisms)

    Intuition: HomFunctors play some special role in the category of functors.
    They serve for the same purposes as Free Monoids

    It's enough to define this NaT on one obj (i.e. set ℂ(a,a)) and moreover
    it's enough to define it on one point in this set i.e. the identity on a.
    The rest of the NaT is transported from this point.

    (                     ) ⋍ F a
              ⎜                ⎜
              ⎜                +-- Container of a (a data structure)
              +------------------- Polymorphic higher order function

    (∀ x : (a -> x) -> F x) ⋍ F a
              ⎜     ⎜   ⎜      ⎜
              ⎜     ⎜   ⎜      +-- Container of a (a data structure)
              ⎜     ⎜   +--------- Functor
              ⎜     +------------- NaT i.e. Polymorphic higher order function
              +------------------- ...

    I.e. the NaT and the Container can replace each other

    [ℂ,Set](ℂ(a,-), ℂ(b,-) ⋍ ℂ(b,a)

*** Adjunctions: weakening of "equality" of Categories
    "inverse" is defined only for functions not functors
*** Adjointness - constructing / generating principle
    - Adjunctions/Adjoins are monads???
    Adjoin examples:
    (-) x A (product) ⊣ (-)^A (exponential)
    '+' (coproduct) ⊣ '∆' (pairing) ⊣ 'x' (product)
    induction, recursion, Natural Numbers (inductively defined), Lists, ...
    conjunction, disjunction, True, False, Exponentiation
    Quantifiers: ∀ Every, ∃ Exists; Σ Sigma, Π Pi

** Natural Transformation: a way of/for comparing functors
   - maps morphism(s) to commuting diagram(s) (naturality squares).
     i.e. comorphism: replacing a square of (complex) relations with a single morphism
   - picks a morphish between two objs; Picking 1 morphishm from a homset
   - Components of NaT
   - Composing functor acting on an obj with a functor acting on a morphishm
     Alpha b * F f

   - polymorphic function

   - Functor is a container, NaT repackages the container

** Fibre: a buch of points mapped to the same value; invertibility of a function to a fibre
** Abstraction: i.e. non-invertibility
   - from all properties (i.e. all points of a fibre) I'm interested only in one
   - e.g. I'm not interested in what was the exact input value of a function,
     I'm interested only if it was an even or odd value
** Modeling: mapping / injecting
   * Category ℂ = (Obj, hom, ◦, id)
   Obj - Class of Objects: A, B, C, ... (Objs are in fact Types / Propositions)
   hom - Morphisms (arrows): f, g, h, ... (morphisms are Computation / Proofs)
   ◦ - function c for composing morphisms: associative
   ◦ - morphism composition: hom(A, B) × hom(B, C) → hom(A, C): g ◦ f; it's a partialy binary operation on Mor(CAT::)
   A collection of arrows and morphism that can be composed if they are adjacent.
   A structure packing structures of the same type (same category) and structure preserving mappings between them.
   id - identity morphism on object A: id(A)
   Small Category: all objs and morphisms are sets
   Localy Small Category: ∀ A,B: Hom(A, B) is a set
   Sheaf (Garbe, Faisceau, zvazok)- tool for tracking locally defined data
   Presheaf: Functor F: ℂop → Set
** HomSet: Homℂ(A,B) = {f: A → B} - set of all morphisms A → B in category ℂ (Objs of ℂ don't need to be sets)
   External vs. Internal Homset

** Free Monoid: has an unique mapping to every other monoid
** HomFunctor: Functor to category of Sets; has a NaT to every other functor; this NaT is not unique but limited
   Reader functor in Haskell
*** Covariant functor: Hom(A,–) : ℂ → Set;
    G f :: (a -> b) -> (G a -> G b); Same directions in src and dst Category
    Hom(A,–) maps each object X in C to the set of morphisms, Hom(A, X)
    Hom(A,–) maps each morphism f : X → Y to the function
    Hom(A, f) : Hom(A, X) → Hom(A, Y) given by

*** Contravariant functor: Hom(–,B) : ℂ → Set
    G f :: (a -> b) -> (G b -> G a); Reverse directions in src and dst Category
    Hom(–,B) maps each object X in C to the set of morphisms, Hom(X, B)
    Hom(–,B) maps each morphism h : X → Y to the function
    Hom(h, B) : Hom(Y, B) → Hom(X, B) given by

** Representable Functor F: ℂ → Set
   Represents objs of ℂ as sets and functions of ℂ as morphisms between sets.
   i.e. functions "tabulate", "index" can be created; mapping of function to a data-type

   fix obj A ∈ ℂ there is Homℂ(A,_): Homℂ(A, X) → Homℂ(A, Y) where there is a morphism X → Y
   e.g.:
   The forgetful functor Grp → Set on the category of groups (G, *, e) is represented by (Z, 1).
   The forgetful functor Ring → Set on the category of rings is represented by (Z[x], x), the polynomial ring in one variable with integer coefficients.
   The forgetful functor Vect → Set on the category of real vector spaces is represented by (R, 1).
   The forgetful functor Top → Set on the category of topological spaces is represented by any singleton topological space with its unique e
** Naturality condition: Gf ∘ αa = αb ∘ Ff
*** Homomorphism: structure-preserving mapping between 2 algebraic structures (e.g. monoids, groups, rings, vector spaces).
    f(m * n) = f(m) * f(n)

    Individual monoids themselves give category
    Monoids with homomorphisms give category

** Kleisli category:
   Monad: return: a -> m a; bind: m a -> (a -> m b) -> m b
     You can operate on IO Monad
     You can't extract anything from IO Monad (it's lost)
   Comonad: (w a -> b) -> (w b -> c) -> (w a -> c)
     You can extract from IO Monad
     You can't put anything to IO Monad
** TODO Topos, Subobject Classifier etc.: see Bartosz's blog
** Indexed Monad: IxMonad: ibind: m i j a -> (a -> m j k b) -> m i k b
   state composition
   Session Types, Dependent Types, Dependent State Types
* Curry-Howard-Lambek correspondence: Intuitionistic Logic <-> Type Theory <-> Category Theory:
  Function A -> B is a proof of logical implication A => B
  Direct relationship between computer programs and mathematical proofs; from 1940-ties
  Link between Computation and Logic;
  Proofs-as-programs and propositions- or formulae-as-types interpretation;
  Proofs (= Programs) can be executed;
  Typed lambda calculi derived from the Curry–Howard-Lambek paradigm led to software like Coq;
  Curry-Howard-Lambek correspondence might lead to unification between mathematical logic and foundational computer science;
  Popular approach: use monads to segregate provably terminating from potentially non-terminating code

    | INTUITIONISTIC (Constructive) LOGIC (Howard)   | TYPE THEORY - Functional Programming (Curry)                         | CATEGORY THEORY (Lambek) |
    |------------------------------------------------+----------------------------------------------------------------------+--------------------------|
    | Proposition of some type - (something is true) | Type (contract - a set of values that passes the contract)           |                          |
    | Proof of some type                             | Term (A program - guarded fn)                                        |                          |
    | Normalisation (Proof equality)                 | Computation (substitute variable with value)                         |                          |
    |------------------------------------------------+----------------------------------------------------------------------+--------------------------|
    | P implies Q: P -> Q (i.e. there exists one)    | paricular fn of fn of P-contract to guarded fn of Q-contract: P -> Q |                          |
    | -> is constructive implication                 | -> is function from-to                                               |                          |
    | false      -> false (implies)                  | {}       ->  {}  no values (empty set); contract cannot be satisfied |                          |
    | false      -> true                             | {}       ->  {.} (one element set)                                   |                          |
    | true       -> true                             | {.}      ->  {.} (identity function)                                 |                          |
    | true  (not ->) false (does not imply)          | {.} (not ->) {}                                                      |                          |


** Correspondance of type habitation and proposition
   inhabited - has elems / members
   "Either a b" is inhabited if either a or b is inhabited (at least one of them is true / provable)

   Curry: ((a,b) -> c) -> (a -> (b -> c))
   Uncurry: (a -> (b -> c)) -> ((a,b) -> c)

   Eval: a function of two args / a pair
   "((a => b), a) -> b" this is modus-ponens in logic "a => b ∧ a -> b"

    | True proposition | False proposition | Conjunction a ∧ b         | Disjunction a ∨ b           | Implication a => b   |
    | Unit-type        | Void-type         | Pair (a,b)                | Either a b                  | Function type a -> b |
    | sinhabited       | not inhabited     |                           |                             |                      |
    | Terminal obj     | Initial obj       | Categorical product a × b | Categorical coproduct a ⎥ b | Exponential obj b^a  |


    0 - void type - ?
    1 - unit type - 0th-power: terminal obj
    2 - bool type (two possible values): 1st-power: the obj itself
    3 - int type - 2nd-power: product
    4 - real type (if continuum hypothesis holds :-)
    5 - ? type

*** JavaScript & Category Theory
**** Category == Contracts + Functions guarded by contracts

**
| Set theory                  | Category theory                                          | JavaScript                     |
|-----------------------------+----------------------------------------------------------+--------------------------------|
| membership relation         | -                                                        |                                |
| elements                    | objects                                                  | contracts                      |
| sets                        | categories                                               |                                |
| -                           | morphisms (structure-preserving mapping between objects) | functions guarded by contracts |
| functions                   | functors  (maps between categories)                      |                                |
| equations between elements  | isomorphisms between objects                             |                                |
| equations between sets      | equivalences between categories                          |                                |
| equations between functions | natural transformations (maps between functors)          |                                |

Categorification: process of weakening structure, weakening equalities down to natural isomorphisms and then adding-in rules
that these natural isomorphisms have to follow (so it behaves well)
Counting number of elements in sets is decategorification; from category we get set or from set we get a number

Monoid homomorphisms: a function between the sets of monoid elements that preserved the monoid structure
Monoidal functors:    a functor between categories that preserves the monoidal structure (should preserve multiplication)
              from functor(prodn([x, y, ..])) to prodn([functor(x), functor(y), ..])
Monoidal monad:       ???

Functor:
"forget the indexing (domain functor)"

*** Contract = Object
*** Product: examples:
    Objects   - numbers
    Morphisms - functions 'less/greater or equal than'

* Isomorphism (bijection when f is a function on set / sets):
  ∀ f: X → Y  there ∃ g: Y → X such that g ∘ f = idX and f ∘ g = idY; idX, idY are identity morphisms on X, Y
  (f is invertible and g is the inverse of f)

** Category theory - Modeling (new vocabulary)
   | hierarchies                | partial orders     |
   | symmetries                 | group elements ?   |
   | data models                | categories         |
   | agent actions              | monoid actions     |
   | local-to-global principles | sheaves (lanovica) |
   | self-similarity            | operads            |
   | context                    | monads             |


** olog = ontology log
   Different branches of mathematics can be formalized
   into categories. These categories can then be connected together by functors. And the
   sense in which these functors provide powerful communication of ideas is that facts and
   theorems proven in one category can be transferred through a connecting functor to
   yield proofs of an analogous theorem in another category. A functor is like a conductor
   of mathematical truth.

* Mappings: X → Y (Zobrazenia):
** Surjection: all Ys are used;                                     |X| ≥ |Y| (onto; "at least as big")
** Injective:  distinct Xs -> distinct Ys;                          |X| ≤ |Y| (? one-to-one ?)
** Bijection:  exact pairing between X, Y;                          |X| = |Y| (vzajomne jednoznacne zobrazenie, "same size")
** Strict:     Surjection from X to Y but no bijection from Y to X; |X| < |Y| (? double usage of some Ys ?, "strictly bigger")

* Math Structures:
** Monoid (M, *, e); Also a Category 'many' morphisms and 'few' (only one) object M
  (like Group withouth inverse elements)
  M - non-empty set
  * - associative operation: (x * y) * z = x * (y * z)
  e - neutral element of M (identity)

** Group (G, *, e): One set G of elements with a 'multiplication' operation (formalization of symetry concept)
  like Monoid; plus every element has its inverse: x-inverse (dual obj): x * x-inverse = x-inverse * x = e
  (i.e. a Category with one object; every morphism is an isomorphism)
  closure: a and b and a*b must be membembers of the same group
  commutativity is not a part of the group definition: x * y = y * x
** Cyclic Group: generated by one element.
** Semigroup: A set with an associative binary operation: x * y
   generalizes a group by preserving only associativity and closure under the binary operation from the axioms defining a group
** Ring (M, +, *) - Okruh
** PreOrder (A, ≤)
   A - nonempty set
   ≤ - pre-ordering relation: must be
                   - reflexive: a ≤ a
                   - transitive: a ≤ b and b ≤ c then a ≤ c

** PoSet - Partialy Ordered Set (A, ≤); Also a Category with 'few' (only one) morphisms between any two objects and many objects
   A - no-nempty set
   ≤ - relation: must be
                   - reflexive: a ≤ a
                   - transitive: a ≤ b and b ≤ c then a ≤ c
                   - aymetric: a ≤ b and b ≤ a then a = b
** TODO Pointed Set
** TODO Pointed Function
** TODO Top (Topological Space)
** eval, exponent in Category Theory

* Tautology - "this is always true"
* Beta β reduction (computational) / Eta η extentionality principle
  β reduction in computation: Simplify proofs by replacing formal params with terms.

  fst<Alpha, Beta> = Alpha
  snd<Alpha, Beta> = Beta
  (lambda x.Beta)Alpha = [Alpha/x]Beta
  (lambda x.f)x = f

* Type Theory: Extention of lambda calculus with explicit types
** ITT Inentional Type Theory
** OTT Observational Type Theory
   Type of a Variable - a set(?) of possible values of that type
   From context Gamma a M can be derrived such that x:A.B
   Context Gamma, x:A, y:Bx (e.g. x be a number with property Bx, y is a variable for the proof of type Bx)
   What's the point of having a number? Well we can count up to that number.
   Depandent type theory is the master theory of all programming languages. If you understand dependent type theory then you understand everything (every programming language)

   Maybe Type: A or B (e.g. A or Fail, A or AirMessage)

** Homotopy Type Theory: ? Equivalence ?
* Axiom of Choice - see "Type Theory Foundations, Lecture 3-wJLTE8rnqH0.mp4"
"the greatest intelectual achievement???"

Predicate = vyrok = tvrdenie
Proposition = ???

(Banach Tarsky Paradox: Slice up an object with a volume into parts with no volume, and by putting it together get 2 same objects - "create an object for free")

* Haskell / Agda comparison:

|             | Haskell                              | Agda                                     |
|-------------+--------------------------------------+------------------------------------------|
|             |                                      | full higher order logic with existential |
|             |                                      | and universal quantification             |
|-------------+--------------------------------------+------------------------------------------|
| Type system | Unsound                              | sound                                    |
|             | (arbitrary properties can be prooven |                                          |
|             | i.e. every single type is inhabited) |                                          |
|             | (loop : A, loop = loop)              |                                          |
|-------------+--------------------------------------+------------------------------------------|
|             |                                      | ? Always terminates ?                    |

* Modus Pones: applications of a function to an argument: Agda, Coq, Isabelle
** MP naturally generalizes to instationation of universal quantifiers
* Goedel's Incompleteness Theorem:
 Every principle is either (A) too restrictive or (leaves out a good programm) or (B) not restrictive enough (allows some bad programs).
* Full employment Theorem: take (A) and search for a new class to add in order to improve the language withouth allowing bad programs.
* Clojure:
** Namespace is a Type
   Namespace contains fns returning values of the same Type. I.e. it is a set of Proofs of a given Proposition (i.e. of a given Type).
** Use morphism from "complicated" Types (i.e. Products consisting of many Types. E.g. maps each having many keys) to subsets of (if possible natural) numbers.
   These subsets should be in fact monads

   inl(...) - injection to the left
   inr(...) - injection to the right

   (A * B) and (A + B) could be seen as a product (e.g. join) and coproduct (e.g. disjoint union) of A and B

* Theory of Reflexive Domain 1:21 Video 2
* Logic examples:
  | Logical Judgement   | Branch of Logic   | Computation phenomenon                                      |
  |---------------------+-------------------+-------------------------------------------------------------|
  | K knows A           | Epistemic Logic   | Distributed Computing                                       |
  | A is true at time t | Temporal Logic    | Reactive Programming (partial evaluation)                   |
  | A is a resource     | Linear Logic      | Concurrent Computation (π calculus)                         |
  | A is possible       | Monadic Lax Logic | Generic effects (monads, state, exception)                  |
  | A is valid          | Modal Logic       | Runtime code generation, code & eval constructs in the lang |
  |                     |                   | Different modes of truth                                    |


  TODO difference between branches of logic

** Linear Logic: limited resources: construction / descruction
   ? Unique pointers in C++ ?, "Stuff moved from place to place and it cannot be used twice only once"
** Intuitionistic (Constructive) Logic: endless resources, no need for construction / descruction
** Propositional Logic: AND, OR, NOT, IF-THEN, IS-EQUIVALENT-TO
** Predicate Logic: dependence on free variables, has Universal quantifiers, variables, functions
** Intuitionistic Logic
** Higher order logic

* Impossibility of a perfect type-checker for a programming language
  It it’s impossible to have a procedure that figures out whether an arbitrary
  program halts, it’s easy to show that it’s impossible to have a procedure that
  is a perfect recognizer for any overall run time property.

  A program that type-checks is guaranteed not to cause a run-time type-error.
  But since it’s impossible to recognize perfectly when programs won’t cause
  type-errors, it follows that the type-checker must be rejecting programs that
  really wouldn’t cause a type-error. The conclusion is that no type-checker is
  perfect—you can always do better!
* Krakatoa and Jessie: verification tools for Java and C programs
  Why3: platform for deductive program verification
  git clone https://scm.gforge.inria.fr/anonscm/git/why3/why3.git
  A user can write WhyML programs directly and get correct-by-construction OCaml programs through an automated extraction mechanism



* Trinity 1. Logic & Proof Theory: Philosophy; 2. Type Theory: Computer Science; 3. Category Theory: Mathematics
* Proof Theory: Proof of soundness, proof of completeness
* PT 1 - Judgements & Propositions 
** judgement (obj of knowledge); judgemens are made about propositions
   'A is true', 'A is false', M : A - M is a proof of A i.e. M is a program which has a type of A
   'A' - proposition
   'true' - judgement on a proposition

  experiment, observation
  sampling, counter examples
  judge, jury, religion, boss, conviction "No bugs in my code!"
  "I don't see why not": psycho (the oposing party must find argument)

  A mathematical proof is a verification of a proposition by a chain of logical deductions from a set of axioms

  Proposition is a statement: can be true or false
  Predicate is a proposition: truth depends on the values of variable(s)

  Verificationist: The meaning of a connective is given by it's introduction rule(s)
  'A and B' is true; A & B : true

** Local soundness of the elimination rules: elim. rules are not too strong
   - no information is gained by applying and eliminating a particular rule
** Local completeness: elim. rules not too weak
** LOcal expantion: witness for the completeness of the rules
* PT 2 - Computational Interpretation: Curry Howard Isomorphism
  - Capturing generic notion of effect: functional programming monad from logical point of view
  - Computational interpretations of monad come out of logical considerations
  - Quote & Eval (not presented in the lecture)

  Lax proposition: 'there is something weaker then truth'; 'Possible truth'; It
  may or may not be true (in case of non-terminating computation or it might
  terminate with some other effects on the way)

  ◯ A : true  A - proposition, ◯ - 'circle'; 'A is true in the lax sense'; Monad A
  Monad - when interacting with real world a failure is always one of the eventualities
        - monad laws are proof-equalities
* PT 3 - Proof Search & Sequent Calculus
