exempli gratia: e.g.

- solution of a Differential Equations (DE) is a function, not value.

* Statistics:
** Data:
                Nominal Data                Interval / Ratio Data
                ━━━━━━━━━━━━━━━━━━━━     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
               ┃  +-----------------+ ┃   ┃                                    +-------------------+ ┃
               ┃  | Test for        | ┃   ┃                                    | Test for a mean   | ┃
               ┃  | Proportion      | ┃   ┃                                    |                   | ┃
               ┃  +-----------------+ ┃   ┃                                    +-------------------+ ┃
               ┃                      ┃   ┃                                                          ┃
               ┃  +-----------------+ ┃   ┃ +-------------------------+                              ┃
               ┃  | Difference of   | ┃   ┃ | difference of two means |                              ┃
               ┃  | two proportions | ┃   ┃ | (independent samples)   |                              ┃
               ┃  +-----------------+ ┃   ┃ +-------------------------+                              ┃
               ┃                      ┃   ┃                                                          ┃
               ┃  +-----------------+ ┃   ┃ +-------------------------+        +-------------------+ ┃
               ┃  | Chi-sq test for | ┃   ┃ | Regression analysis     |        | Difference of two | ┃
               ┃  | independence    | ┃   ┃ |                         |        | means (paired)    | ┃
               ┃  +-----------------+ ┃   ┃ +-------------------------+        +-------------------+ ┃
                ━━━━━━━━━━━━━━━━━━━━     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

** Samples:
                ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 One           ┃  +-----------------+                                          +-------------------+ ┃
 Sample        ┃  | Test for        |                                          | Test for a mean   | ┃
               ┃  | Proportion      |                                          |                   | ┃
               ┃  +-----------------+                                          +-------------------+ ┃
                ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

                ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 Two           ┃  +-----------------+       +-------------------------+                              ┃
 Samples       ┃  | Difference of   |       | difference of two means |                              ┃
               ┃  | two proportions |       | (independent samples)   |                              ┃
               ┃  +-----------------+       +-------------------------+                              ┃
                ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

                ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 One           ┃  +-----------------+       +-------------------------+        +-------------------+ ┃
 Sample,       ┃  | Chi-sq test for |       | Regression analysis     |        | Difference of two | ┃
 Two           ┃  | independence    |       |                         |        | means (paired)    | ┃
 Measures      ┃  +-----------------+       +-------------------------+        +-------------------+ ┃
                ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

** Purpose:
                ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  Testing      ┃  +-----------------+                                          +-------------------+ ┃
  against      ┃  | Test for        |                                          | Test for a mean   | ┃
  a value      ┃  | Proportion      |                                          |                   | ┃
               ┃  +-----------------+                                          +-------------------+ ┃
                ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━                         ┃
                                                                            ┃                        ┃
                ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━    ┃                        ┃
 Comparing     ┃  +-----------------+       +-------------------------+  ┃  ┃                        ┃
  two          ┃  | Difference of   |       | difference of two means |  ┃  ┃                        ┃
 statistics    ┃  | two proportions |       | (independent samples)   |  ┃  ┃                        ┃
               ┃  +-----------------+       +-------------------------+  ┃  ┃                        ┃
                ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━    ┃                        ┃
                                                                            ┃                        ┃
                ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━    ┃                        ┃
 Looking       ┃  +-----------------+       +-------------------------+  ┃  ┃  +-------------------+ ┃
 for           ┃  | Chi-sq test for |       | Regression analysis     |  ┃  ┃  | Difference of two | ┃
 relationships ┃  | independence    |       |                         |  ┃  ┃  | means (paired)    | ┃
               ┃  +-----------------+       +-------------------------+  ┃  ┃  +-------------------+ ┃
                ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━    ━━━━━━━━━━━━━━━━━━━━━━






* hierarchy:
** what is needed to understand X:
   a big tree and paths through this tree
** where leads understanding of X1, X2, .. Xn:
   prospects, applications in other science fields, everyday life etc.
** what's the next step:
   why to study Z and not W after understanding X1, X2 .. Xn in dependency of the field of some interest
* WebApp, Datomic/Keystore (timestamps)/ Clojurescript
* Start with http://eu.ixl.com/
* Take a look at
** Knowledge Map: https://www.khanacademy.org/exercisedashboard




http://www.gametheory.net/
** http://www.reddit.com/r/math
** Ask:
   Christofer


* Game Theory: Nash Equilibrum (NE):
  Each players best response to the others
  Nobody has an incentive to deviate from their actions if an equilibrum is played

* TODO
1. write down action profiles for everyone (the matrix) and calculate optimal mixed strategies for everyone in order to get NE
2. Calculate maxmin strategy and maxmin value (i.e. when the other guys do max harm the i-guy)
** games beyond 2x2 (See the 2-4 Hardness lecture):
   Linear Complementarity formulation
   Support Enumeration Method
* Go over the book from the Prof. from Karlsruhe
* Higher order logic


* Hypotheses, Conjectures & Theorems:
** Goldbach conjencture: ∀ (Every) even integer ≧ 2 is a ∑ of two primes
** Riemann hypothesis: The real part of every non-trivila zero of the Zeta function is 1/2 (prime numbers)
** Poincare conjencture: ∀ (Every) simply connected, closed 3-manifold is homeomorfic to the 3-sphere (Donuts)
** P vs. NP: ∀ problem whose solution can be quickly verified by a computer can also be quickly solved by a computer
** Fermant's Last Theorem: ∀ (For all) n ≧ 2 ∉ (there's no) x,y,z such that xⁿ + yⁿ = zⁿ
** Continuum Hypothesis: There is no set whose cardinality is strictly between that of the integers and that of the real numbers.
   Notes: R surj P(N) (Power series - Mocninovy rad)
** Fundamental Theorem of Arithmetics: Every positive integer n can be written in a unique way as a product of primes.


Russells paradox - Barbiers dilema
* Morphisms:
** Category is:
    A collection of arrows and morphism that can be composed if they are adjacent.
    A structure packing structures of the same type (same category) and structure preserving mappings between them.
*** Homomorphism: structure-preserving map between 2 algebraic structures (e.g. groups, rings, vector spaces).
    Functor: homomorphism between 2 categories

    Individual monoids themselves give category
    Monoids with homomorphisms give category

    TODO Pointed Sets and Pointed Functions

* Curry-Howard Isomorphism: Logic ⇔ Type Theory (1-to-1 and keeps all properties):
  Direct relationship between computer programs and mathematical proofs;
  Link between Computation and Logic;
  Proofs-as-programs and propositions- or formulae-as-types interpretation;
  Proofs can be run;
  Typed lambda calculi derived from the Curry–Howard paradigm led to software like Coq;
  Curry-Howard correspondence might lead to unification between mathematical logic and foundational computer science;
  Popular approach: use monads to segregate provably terminating from potentially non-terminating code
    | Logic                             ⇒   | ⇐                          Type Theory                             |
    |---------------------------------------+----------------------------------------------------------------------|
    | proposition                           | contract                                                             |
    | (somethins is true)                   | (pics out a set of values that passes the contract)                  |
    | proof                                 | guarded fn                                                           |
    |---------------------------------------+----------------------------------------------------------------------|
    | P implies Q: P → Q (i.e. there ∃ one) | paricular fn of fn of P-contract to guarded fn of Q-contract: P -> Q |
    | → is constructive implication         | → is function from-to                                                |
    | false → false (implies)               | {}  → {}  no values (empty set); contract cannot be satisfied        |
    | false → true                          | {}  → {.} (one element set)                                          |
    | true  → true                          | {.} → {.} (identity function)                                        |
    | true  ↛ false (does not imply)        | {.} ↛ {}                                                             |


*** Quadruple: CAT = (O, hom, id, ◦) consisting of
    O  : class of CAT-objects: Ob(A); e.g. A,B are CAT-objects
    hom: set (?or class?) of CAT-morphisms: hom(A, B) = {f | f: A → B } (e.g. arrows)
    (class of all CAT-morphisms: Mor(CAT) = Union of all sets hom(A,B) in CAT)
    id : set of identity morphisms for every CAT-obj
    ◦  : morphism composition: hom(a, b) × hom(b, c) → hom(a, c): g ◦ f; it's a partialy binary operation on Mor(CAT::)

*** JavaScript & Category Theory
**** Category ==  Contracts + Functions guarded by contracts

**
| Set theory                  | Category theory                                          | JavaScript                     |
|-----------------------------+----------------------------------------------------------+--------------------------------|
| membership relation         | -                                                        |                                |
| elements                    | objects                                                  | contracts                      |
| sets                        | categories                                               |                                |
| -                           | morphisms (structure-preserving mapping between objects) | functions guarded by contracts |
| functions                   | functors  (maps between categories)                      |                                |
| equations between elements  | isomorphisms between objects                             |                                |
| equations between sets      | equivalences between categories                          |                                |
| equations between functions | natural transformations (maps between functors)          |                                |

Categorification: process of weakening structure, weakening equalities down to natural isomorphisms and then adding-in rules
that these natural isomorphisms have to follow (so it behaves well)
Counting number of elements in sets is decategorification; from category we get set or from set we get a number

Monoid homomorphisms: a function between the sets of monoid elements that preserved the monoid structure
Monoidal functors:    a functor between categories that preserves the monoidal structure (should preserve multiplication)
                      from functor(prodn([x, y, ..])) to prodn([functor(x), functor(y), ..])
Monoidal monad:       ???

*** Contract == Object

*** Product: examples:
    Objects   - numbers
    Morphisms - functions 'less/greater or equal than'

* Tensor: most general bilinear operation; Notation ⊗
* Isomorphism f: X -> Y
  ∃ fn g: Y → X such that g ∘ f = idX and f ∘ g = idY
  (f is invertible and g is the inverse of f)

** Category theory - Modeling (new vocabulary)
   | hierarchies                | partial orders     |
   | symmetries                 | group elements ?   |
   | data models                | categories         |
   | agent actions              | monoid actions     |
   | local-to-global principles | sheaves (lanovica) |
   | self-similarity            | operads            |
   | context                    | monads             |


** Catergory of sets (Set)
   Hom-Set(X, Y): the set of functions X -> Y

** olog = ontology log
   Different branches of mathematics can be formalized
   into categories. These categories can then be connected together by functors. And the
   sense in which these functors provide powerful communication of ideas is that facts and
   theorems proven in one category can be transferred through a connecting functor to
   yield proofs of an analogous theorem in another category. A functor is like a conductor
   of mathematical truth.



* Mappings: X -> Y (Zobrazenia):
** Surjection: every elem in Y is "used";                           |X| ≥ |Y| (onto; "at least as big")
** Injective:  distinct Xs -> distinc Ys;                           |X| ≤ |Y| (? one-to-one ?)
** Bijection:  exact pairing between X, Y;                          |X| = |Y| (vzajomne jednoznacne zobrazenie, "same size")
** Strict:     Surjection from X to Y but no bijection from Y to X; |X| < |Y| (? double usage of some Ys ?, "strictly bigger")

* Probability:
** Probability rules:
Difference Rule: P(B − A) = P(B) - P(A ∩ B)
Inclusion-Exclusion: P(A ∪ B) = P(A) + P(B) − P(A ∩ B)
Boole’s Inequality: P(A ∪ B) <= P(A) + P(B)
Monotonicity: If A ⊆ B then P(A) <= P(B)

** Ordinary conditional probability P(A ∣ B) = P(A ∩ B) / P(B):

| Objective Health | Objective Health | Test result  | Test result | Outcome probability | Event T ∩ H:                      |
| ill / healthy    |      probability |              | probability |            P(T ∩ H) | P(T ∣ H ) =                       |
| H                |             P(H) | T            |        P(T) |       (* P(H) P(T)) | (/ P(T ∩ H) P(H))                 |
|------------------+------------------+--------------+-------------+---------------------+-----------------------------------|
| really-ill       |              0.1 | test-ill     |         0.9 |                0.09 | (/ 0.09 (+ 0.09 0.27)) = 0.25     |
| really-ill       |              0.1 | test-healthy |         0.1 |                0.01 | (/ 0.01 (+ 0.01 0.63)) = 0.015625 |
| really-healthy   |              0.9 | test-ill     |         0.3 |                0.27 | (/ 0.27 (+ 0.09 0.27)) = 0.75     |
| really-healthy   |              0.9 | test-healthy |         0.7 |                0.63 | (/ 0.63 (+ 0.01 0.63)) = 0.984375 |

- Generall test correctness: 0.09 + 0.63 = 0.72 (i.e. proper results for ill + proper results for healthy persons)
- Just guessing "everybody's healthy" gives 90% "generall test correctness" because the test is wrong only for ill patients and they make up 10% of the population.


# ----------------------------------------
#		       test positive
#                   +---- 0.9            0.1 * 0.9 = 0.09
#          ill      |
#    +---- 0.1 -----+
#    |              |  test negative
#    |              +---- 0.1            0.1 * 0.1 = 0.01
#    |
#    |
#  ---+                test positive
#    |              +---- 0.3            0.9 * 0.3 = 0.27
#    |              |
#    +--- 0.9 ------+
#       healthy     |
#                   |  test negative
#                   +---- 0.7            0.9 * 0.7 = 0.63

;; test is negative i.e. says "you're healthy" and the patient is really ill (has the condition)
(/ 0.01 (+ 0.01 0.63)) = 0.015625

;; test is positive i.e. says "you're ill" and the patient is really ill (has the condition)
(/ 0.09 (+ 0.09 0.27)) = 0.25

;; test is negative i.e. says "you're healthy" and the patient is really health (doesn't have the condition)y
(/ 0.63 (+ 0.01 0.63)) = 0.984375

;; test is posivite i.e. says "you're ill" and the patient is really healthy (doesn't have the condition)
(/ 0.27 (+ 0.09 0.27)) = 0.75

** A posteriori conditional probability P(B ∣ A) = P(A ∩ B) / P(B):
   if event B precedes event A in time. Example: The probability it was cloudy this morning, given that it rained in the afternoon.


#+BEGIN_SRC clojure
(defn x[] (+ 1 2))
(x)
#+END_SRC

#(reduce * (range 1 (inc %)))

Bodil Stokke
* presentation in emacs
* building own lisp (own unicode chars
* instaparse by Mark Engelbers (project.clj - clojars; )
  - :require instaparse.core as insta ...
(def p (insta/parser ""))

  - vsadepritomne ako regexps
    EBNF extended BNF (Backchus Naur Format)`
