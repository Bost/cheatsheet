- TODO: install scheme; see what Ambrose et. al have done
- TODO use trace to analyse examples from "The Reasonable Schemer"
- recursive calls - creates "triangle" on the stack
- stack space constrains can be avoided by "registering" (functions params turned to registers)
- meaning of call with continuations is important for type theory
- complicated controll structure - implement at first with continuations and then traditionally

- solution of a Differential Equations (DE) is a function, not value.

* Statistics:
** Data:
        Nominal Data                Interval / Ratio Data
        ━━━━━━━━━━━━━━━━━━━━     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
           ┃  +-----------------+ ┃   ┃                                    +-------------------+ ┃
           ┃  | Test for        | ┃   ┃                                    | Test for a mean   | ┃
           ┃  | Proportion      | ┃   ┃                                    |                   | ┃
           ┃  +-----------------+ ┃   ┃                                    +-------------------+ ┃
           ┃                      ┃   ┃                                                          ┃
           ┃  +-----------------+ ┃   ┃ +-------------------------+                              ┃
           ┃  | Difference of   | ┃   ┃ | difference of two means |                              ┃
           ┃  | two proportions | ┃   ┃ | (independent samples)   |                              ┃
           ┃  +-----------------+ ┃   ┃ +-------------------------+                              ┃
           ┃                      ┃   ┃                                                          ┃
           ┃  +-----------------+ ┃   ┃ +-------------------------+        +-------------------+ ┃
           ┃  | Chi-sq test for | ┃   ┃ | Regression analysis     |        | Difference of two | ┃
           ┃  | independence    | ┃   ┃ |                         |        | means (paired)    | ┃
           ┃  +-----------------+ ┃   ┃ +-------------------------+        +-------------------+ ┃
        ━━━━━━━━━━━━━━━━━━━━     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

** Samples:
        ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 One           ┃  +-----------------+                                          +-------------------+ ┃
 Sample        ┃  | Test for        |                                          | Test for a mean   | ┃
           ┃  | Proportion      |                                          |                   | ┃
           ┃  +-----------------+                                          +-------------------+ ┃
        ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 Two           ┃  +-----------------+       +-------------------------+                              ┃
 Samples       ┃  | Difference of   |       | difference of two means |                              ┃
           ┃  | two proportions |       | (independent samples)   |                              ┃
           ┃  +-----------------+       +-------------------------+                              ┃
        ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 One           ┃  +-----------------+       +-------------------------+        +-------------------+ ┃
 Sample,       ┃  | Chi-sq test for |       | Regression analysis     |        | Difference of two | ┃
 Two           ┃  | independence    |       |                         |        | means (paired)    | ┃
 Measures      ┃  +-----------------+       +-------------------------+        +-------------------+ ┃
        ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

** Purpose:
        ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  Testing      ┃  +-----------------+                                          +-------------------+ ┃
  against      ┃  | Test for        |                                          | Test for a mean   | ┃
  a value      ┃  | Proportion      |                                          |                   | ┃
           ┃  +-----------------+                                          +-------------------+ ┃
        ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━                         ┃
                                        ┃                        ┃
        ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━    ┃                        ┃
 Comparing     ┃  +-----------------+       +-------------------------+  ┃  ┃                        ┃
  two          ┃  | Difference of   |       | difference of two means |  ┃  ┃                        ┃
 statistics    ┃  | two proportions |       | (independent samples)   |  ┃  ┃                        ┃
           ┃  +-----------------+       +-------------------------+  ┃  ┃                        ┃
        ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━    ┃                        ┃
                                        ┃                        ┃
        ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━    ┃                        ┃
 Looking       ┃  +-----------------+       +-------------------------+  ┃  ┃  +-------------------+ ┃
 for           ┃  | Chi-sq test for |       | Regression analysis     |  ┃  ┃  | Difference of two | ┃
 relationships ┃  | independence    |       |                         |  ┃  ┃  | means (paired)    | ┃
           ┃  +-----------------+       +-------------------------+  ┃  ┃  +-------------------+ ┃
        ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━    ━━━━━━━━━━━━━━━━━━━━━━





* hierarchy:
** what is needed to understand X:
   a big tree and paths through this tree
** where leads understanding of X1, X2, .. Xn:
   prospects, applications in other science fields, everyday life etc.
** what's the next step:
   why to study Z and not W after understanding X1, X2 .. Xn in dependency of the field of some interest
* WebApp, Datomic/Keystore (timestamps)/ Clojurescript
* Start with http://eu.ixl.com/
* Take a look at
** Knowledge Map: https://www.khanacademy.org/exercisedashboard




http://www.gametheory.net/
** http://www.reddit.com/r/math
** Ask:
   Christofer

* Game Theory: Nash Equilibrum (NE):
  Each players best response to the others
  Nobody has an incentive to deviate from their actions if an equilibrum is played

  Pareto Efficiency - whenever all agents agree on ordering of outcomes the social welfare function selects that ordering
  Independence of Irrelevant Alternatives - if the selected ordering between two outcomes depends only on the relative ordering they are given by the agents
  Dictator - single agent whose preferencies always determine the social ordering
  Arrows Theorem - any social welfare function that is pareto efficient and independent of irrelevant alternatives is dictatorial

* TODO
1. write down action profiles for everyone (the matrix) and calculate optimal mixed strategies for everyone in order to get NE
2. Calculate maxmin strategy and maxmin value (i.e. when the other guys do max harm the i-guy)

** games beyond 2x2 (See the 2-4 Hardness lecture):
   Linear Complementarity formulation
   Support Enumeration Method

* Go over the book from the Prof. from Karlsruhe
* Higher order logic
* Hypotheses, Conjectures & Theorems:
** Goldbach conjencture: ∀ (Every) even integer ≧ 2 is a ∑ of two primes
** Riemann hypothesis: The real part of every non-trivila zero of the Zeta function is 1/2 (prime numbers)
** Poincare conjencture: ∀ (Every) simply connected, closed 3-manifold is homeomorfic to the 3-sphere (Donuts)
** P vs. NP: ∀ problem whose solution can be quickly verified by a computer can also be quickly solved by a computer
** Fermant's Last Theorem: ∀ (For all) n ≧ 2 ∉ (there's no) x,y,z such that xⁿ + yⁿ = zⁿ
** Continuum Hypothesis: There is no set whose cardinality is strictly between that of the integers and that of the real numbers.
   Notes: R surj P(N) (Power series - Mocninovy rad)
** Fundamental Theorem of Arithmetics: Every positive integer n can be written in a unique way as a product of primes.


Russells paradox - Barbiers dilema

* Morphisms:
* Lambda Calculus: formal calculus for manipulating functions
* Category Theory: abstract algebra of abstract functions: "The Arrows Count"
** Category ℂ = (Obj, hom, ◦, id)
    Obj - Class of Objects: A, B, C, ...
    hom - Morphisms (arrows): f, g, h, ...
    ◦ - function c for composing morphisms: associative
    ◦ - morphism composition: hom(A, B) × hom(B, C) → hom(A, C): g ◦ f; it's a partialy binary operation on Mor(CAT::)
    A collection of arrows and morphism that can be composed if they are adjacent.
    A structure packing structures of the same type (same category) and structure preserving mappings between them.
    id - identity morphism on object A: id(A)
    Small Category: all objects create a set and all morphisms create a set
    Localy Small Category: ∀ A,B: Hom(A, B) is a set
    Sheaf (Garbe, Faisceau, zvazok)- tool for tracking locally defined data
    Presheaf: Functor F: ℂop → Set

** Hom-Set(A, B):
   Homℂ(A, B) = {f: A → B} - set of all morphisms A → B in category ℂ (Objects of ℂ don't need to be sets)

** Representable Functor F: ℂ → Set
   "Representing objects and morphisms of C as sets and functions in Set"
   fix object A ∈ ℂ there is Homℂ(A, -): Homℂ(A, X) → Homℂ(A, Y) where there is a morphism X → Y
   e.g.:
   The forgetful functor Grp → Set on the category of groups (G, *, e) is represented by (Z, 1).
   The forgetful functor Ring → Set on the category of rings is represented by (Z[x], x), the polynomial ring in one variable with integer coefficients.
   The forgetful functor Vect → Set on the category of real vector spaces is represented by (R, 1).
   The forgetful functor Top → Set on the category of topological spaces is represented by any singleton topological space with its unique element.

** Naturality condition:
    G f ∘ αa = αb ∘ F f

*** Homomorphism f: structure-preserving mapping between 2 algebraic structures (e.g. groups, rings, vector spaces).
    f(m * n) = f(m) * f(n)
    Functor: homomorphism between 2 categories

    Individual monoids themselves give category
    Monoids with homomorphisms give category

* Curry-Howard-Lambek correspondence: Logic <-> Type Theory <-> Category Theory:
  Function A -> B is a proof of logical implication A => B
  Direct relationship between computer programs and mathematical proofs; from 1940-ties
  Link between Computation and Logic;
  Proofs-as-programs and propositions- or formulae-as-types interpretation;
  Proofs (= Programs) can be executed;
  Typed lambda calculi derived from the Curry–Howard-Lambek paradigm led to software like Coq;
  Curry-Howard-Lambek correspondence might lead to unification between mathematical logic and foundational computer science;
  Popular approach: use monads to segregate provably terminating from potentially non-terminating code

    | LOGIC (Howard)                                 | TYPE THEORY (Curry)                                                  | CATEGORY THEORY (Lambek) |
    |------------------------------------------------+----------------------------------------------------------------------+--------------------------|
    | Proposition of some type - (something is true) | Type (contract - a set of values that passes the contract)           |                          |
    | Proof of some type                             | Term (A program - guarded fn)                                        |                          |
    | Normalisation (Proof equality)                 | Computation (substitute variable with value)                         |                          |
    |------------------------------------------------+----------------------------------------------------------------------+--------------------------|
    | P implies Q: P -> Q (i.e. there exists one)    | paricular fn of fn of P-contract to guarded fn of Q-contract: P -> Q |                          |
    | -> is constructive implication                 | -> is function from-to                                               |                          |
    | false      -> false (implies)                  | {}       ->  {}  no values (empty set); contract cannot be satisfied |                          |
    | false      -> true                             | {}       ->  {.} (one element set)                                   |                          |
    | true       -> true                             | {.}      ->  {.} (identity function)                                 |                          |
    | true  (not ->) false (does not imply)          | {.} (not ->) {}                                                      |                          |


*** JavaScript & Category Theory
**** Category ==  Contracts + Functions guarded by contracts

**
| Set theory                  | Category theory                                          | JavaScript                     |
|-----------------------------+----------------------------------------------------------+--------------------------------|
| membership relation         | -                                                        |                                |
| elements                    | objects                                                  | contracts                      |
| sets                        | categories                                               |                                |
| -                           | morphisms (structure-preserving mapping between objects) | functions guarded by contracts |
| functions                   | functors  (maps between categories)                      |                                |
| equations between elements  | isomorphisms between objects                             |                                |
| equations between sets      | equivalences between categories                          |                                |
| equations between functions | natural transformations (maps between functors)          |                                |

Categorification: process of weakening structure, weakening equalities down to natural isomorphisms and then adding-in rules
that these natural isomorphisms have to follow (so it behaves well)
Counting number of elements in sets is decategorification; from category we get set or from set we get a number

Monoid homomorphisms: a function between the sets of monoid elements that preserved the monoid structure
Monoidal functors:    a functor between categories that preserves the monoidal structure (should preserve multiplication)
              from functor(prodn([x, y, ..])) to prodn([functor(x), functor(y), ..])
Monoidal monad:       ???

Functor:
"forget the indexing (domain functor)"

*** Contract = Object
*** Product: examples:
    Objects   - numbers
    Morphisms - functions 'less/greater or equal than'

* Tensor: most general bilinear operation; Notation ⊗
* Isomorphism (bijection of set):
  ∀ f: X → Y  there ∃ g: Y → X such that g ∘ f = idX and f ∘ g = idY; idX, idY are identity morphisms on X, Y
  (f is invertible and g is the inverse of f)

** Category theory - Modeling (new vocabulary)
   | hierarchies                | partial orders     |
   | symmetries                 | group elements ?   |
   | data models                | categories         |
   | agent actions              | monoid actions     |
   | local-to-global principles | sheaves (lanovica) |
   | self-similarity            | operads            |
   | context                    | monads             |


** olog = ontology log
   Different branches of mathematics can be formalized
   into categories. These categories can then be connected together by functors. And the
   sense in which these functors provide powerful communication of ideas is that facts and
   theorems proven in one category can be transferred through a connecting functor to
   yield proofs of an analogous theorem in another category. A functor is like a conductor
   of mathematical truth.

* Mappings: X → Y (Zobrazenia):
** Surjection: every elem in Y is "used";                           |X| ≥ |Y| (onto; "at least as big")
** Injective:  distinct Xs → distinc Ys;                           |X| ≤ |Y| (? one-to-one ?)
** Bijection:  exact pairing between X, Y;                          |X| = |Y| (vzajomne jednoznacne zobrazenie, "same size")
** Strict:     Surjection from X to Y but no bijection from Y to X; |X| < |Y| (? double usage of some Ys ?, "strictly bigger")

* Probability:
** Probability rules:
Difference Rule: P(B − A) = P(B) - P(A ∩ B)
Inclusion-Exclusion: P(A ∪ B) = P(A) + P(B) − P(A ∩ B)
Boole’s Inequality: P(A ∪ B) <= P(A) + P(B)
Monotonicity: If A ⊆ B then P(A) <= P(B)

** Ordinary conditional probability P(A ∣ B) = P(A ∩ B) / P(B):

| Objective Health | Objective Health | Test result  | Test result | Outcome probability | Event T ∩ H:                      |
| ill / healthy    |      probability |              | probability |            P(T ∩ H) | P(T ∣ H ) =                       |
| H                |             P(H) | T            |        P(T) |       (* P(H) P(T)) | (/ P(T ∩ H) P(H))                 |
|------------------+------------------+--------------+-------------+---------------------+-----------------------------------|
| really-ill       |              0.1 | test-ill     |         0.9 |                0.09 | (/ 0.09 (+ 0.09 0.27)) = 0.25     |
| really-ill       |              0.1 | test-healthy |         0.1 |                0.01 | (/ 0.01 (+ 0.01 0.63)) = 0.015625 |
| really-healthy   |              0.9 | test-ill     |         0.3 |                0.27 | (/ 0.27 (+ 0.09 0.27)) = 0.75     |
| really-healthy   |              0.9 | test-healthy |         0.7 |                0.63 | (/ 0.63 (+ 0.01 0.63)) = 0.984375 |

- Generall test correctness: 0.09 + 0.63 = 0.72 (i.e. proper results for ill + proper results for healthy persons)
- Just guessing "everybody's healthy" gives 90% "generall test correctness" because the test is wrong only for ill patients and they make up 10% of the population.


# ----------------------------------------
#              test positive
#                   +---- 0.9            0.1 * 0.9 = 0.09
#          ill      |
#    +---- 0.1 -----+
#    |              |  test negative
#    |              +---- 0.1            0.1 * 0.1 = 0.01
#    |
#    |
#  ---+                test positive
#    |              +---- 0.3            0.9 * 0.3 = 0.27
#    |              |
#    +--- 0.9 ------+
#       healthy     |
#                   |  test negative
#                   +---- 0.7            0.9 * 0.7 = 0.63

;; test is negative i.e. says "you're healthy" and the patient is really ill (has the condition)
(/ 0.01 (+ 0.01 0.63)) = 0.015625

;; test is positive i.e. says "you're ill" and the patient is really ill (has the condition)
(/ 0.09 (+ 0.09 0.27)) = 0.25

;; test is negative i.e. says "you're healthy" and the patient is really health (doesn't have the condition)y
(/ 0.63 (+ 0.01 0.63)) = 0.984375

;; test is posivite i.e. says "you're ill" and the patient is really healthy (doesn't have the condition)
(/ 0.27 (+ 0.09 0.27)) = 0.75

** A posteriori conditional probability P(B ∣ A) = P(A ∩ B) / P(B):
   if event B precedes event A in time. Example: The probability it was cloudy this morning, given that it rained in the afternoon.


#+BEGIN_SRC clojure
(defn x[] (+ 1 2))
(x)
#+END_SRC

#(reduce * (range 1 (inc %)))

Bodil Stokke
* instaparse by Mark Engelbers (project.clj - clojars; )
  - :require instaparse.core as insta ...
(def p (insta/parser ""))

  - vsadepritomne ako regexps
    EBNF extended BNF (Backchus Naur Format)`

* Structures
** Monoid (M, *, e); Also a Category 'many' morphisms and 'few' (only one) object M
  (like Group withouth inverse elements)
  M - non-empty set
  * - associative operation: (x * y) * z = x * (y * z)
  e - neutral element of M (identity)

** Group (G, *, e): One set G of elements with a 'multiplication' operation (formalization of symetry concept)
  like Monoid; plus every element has its inverse: x-inverse (dual obj): x * x-inverse = x-inverse * x = e
  (i.e. a Category with one object; every morphism is an isomorphism)
  closure: a and b and a*b must be membembers of the same group
  commutativity is not a part of the group definition: x * y = y * x

** Ring (M, +, *) - Okruh
** PreOrder (A, ≤)
   A - nonempty set
   ≤ - pre-ordering relation: must be
                   - reflexive: a ≤ a
                   - transitive: a ≤ b and b ≤ c then a ≤ c

** PoSet - Partialy Ordered Set (A, ≤); Also a Category with 'few' (only one) morphisms between any two objects and many objects
   A - no-nempty set
   ≤ - relation: must be
                   - reflexive: a ≤ a
                   - transitive: a ≤ b and b ≤ c then a ≤ c
                   - aymetric: a ≤ b and b ≤ a then a = b
** TODO Pointed Set
** TODO Pointed Function

** TODO Top (Topological Space)
** eval, exponent in Category Theory
** Propositional Logic
* TODO definitions


Simplices - analogs of triangles in higher dimensions

* Homology - higher dimensional analogues for studying loops = (alternative to) Homotopy groups
* Fundamental group π₂ - "loops of loops" (loops around sphere - captuers 2-dimensional hole in the sphere)
  πₙ(S-k-upper-index) Homotopy group exists even if n > k; measuring higher dimensional holes in k dimensional sphere
  "Patri" - containment relation

* Homotopy theory -  the indea of paths in a space

* Localy Cartesian Closed Category CCC:
  for every object X sliced category is a CCC
* Cartesian Closed Category CCC:
** it has products  A x B and exponentials B^A for any pair of objects A, B
** it has terminal object 1 (Exists unique map A → 1) (dual is initial object; Top and Bottom Objects)
   i.e. any one-element set (= singleton) is terminal
   DTTO for poset 1 is such an object that any other object is below it

* Universal Mapping Property - UMP
  Consists of Initial and Terminal mapping (morphism).
  The 'double' triangle of Product;

* Beta β reduction (computational) / Eta η extentionality principle
  fst<Alpha, Beta> = Alpha
  snd<Alpha, Beta> = Beta
  (lambda x.Beta)Alpha = [Alpha/x]Beta
  (lambda x.f)x = f

* Beta reduction - computation
  Replace formal params with terms so the proof (proof tree) gets simplified.

* Type Theory
** ITT Inentional Type Theory
** OTT Observational Type Theory
Type of a Variable - a set(?) of possible values of that type
From context Gamma a M can be derrived such that x:A.B
Context Gamma, x:A, y:Bx (e.g. x be a number with property Bx, y is a variable for the proof of type Bx)
What's the point of having a number? Well we can count up to that number.
Depandent type theory is the master theory of all programming languages. If you understand dependent type theory then you understand everything (every programming language)

Maybe Type: A or B (e.g. A or Fail, A or AirMessage)

* Intuitionistic Logic a.k.a Constructive Logic
counts on endless resources - does not need any constructor or destructor.
* Linear Logic
has the notion of Limited resources - has operations of Construction and Descruction
* Axiom of Choice - see "Type Theory Foundations, Lecture 3-wJLTE8rnqH0.mp4"
"the greatest intelectual achievement???"

predicate = vyrok = tvrdenie

(Banach Tarsky Paradox: Slice up an object with a volume into parts with no volume, and by putting it together get 2 same objects - "create an object for free")

* Haskell  vs. Agda

| Haskell                                                                    | Agda                                                                  |
|                                                                            | full higher order logic with existential and universal quantification |
| Unsound type system                                                        | Sound type system                                                     |
| (arbitrary properties can be prooven, i.e. every single type is inhabited) |                                                                       |
| (loop : A, loop = loop)                                                  |                                                                       |

* Modus pones: applications of a function to an argument
Agda, Coq, Isabelle

* Goedel's Incompleteness Theorem:
 Every principle is either (A) too restrictive or (leaves out a good programm) or (B) not restrictive enough (allows some bad programs).
* Full employment Theorem: take (A) and search for a new class to add in order to improve the language withouth allowing bad programs.
* Clojure:
** Namespace is a Type
   Namespace contains fns returning values of the same Type. I.e. it is a set of Proofs of a given Proposition (i.e. of a given Type).
** Use morphism from "complicated" Types (i.e. Products consisting of many Types. E.g. maps each having many keys) to subsets of (if possible natural) numbers.
   These subsets should be in fact monads


inl(...) - injection to the left
inr(...) - injection to the right

(A * B) and (A + B) could be seen as a product (e.g. join) and coproduct (e.g. disjoint union) of A and B

* Category of Types (a.k.a Category of Proofs)
* Theory of Reflexive Domain


1:21 Video 2

* Logic examples:
  | Logical Judgement   | Branch of Logic   | Computation phenomenon                     |
  |---------------------+-------------------+--------------------------------------------|
  | K knows A           | Epistemic Logic   | Distributed Computing                      |
  | A is true at time t | Temporal Logic    | Reactive Programming (partial evaluation)  |
  | A is a resource     | Linear Logic      | Concurrent Computation                     |
  | A is possible       | Monadic Lax Logic | Generic effects (monads, state, exception) |
  | A is valid          | Modal Logic       | Runtime code generation                    |
